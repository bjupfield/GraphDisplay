good but brief overview
https://github.com/corkami/formats/blob/master/image/jpeg.md

video discussing arithmetic coding for jpg, timestamp 10:20, for real explanation
https://www.youtube.com/watch?v=35f43OSIKXk

actual good intro:
https://www.ccoderun.ca/programming/2017-01-31_jpeg/

quantizition table:
https://www.quora.com/What-are-the-design-steps-for-jpeg-quantization-table
http://forum.doom9.org/showthread.php?t=54147&highlight=matrix
https://num.math.uni-goettingen.de/plonka/pdfs/bommer02.pdf
https://www.geeksforgeeks.org/discrete-cosine-transform-algorithm-program/#

jpeg symbols:
https://help.accusoft.com/ImageGear/v19.8/Windows/DLL/IGDLL-10-05.html
https://www.w3.org/Graphics/JPEG/itu-t81.pdf

okay I get it there is no DCT Tables, the alogirithim is just the same across all jpegs,
they all use DCT-II, which then is quantizised by the quanitization tables and is than
huffmaned with huffman tables

ITU defined formulas for RGB to YCbCr Conversion:

E'B = normalized blue = rgb blue (of scale of 256) / 255
E'R = normalized red = rgb red (of scale of 256) / 255
E'G = normalized green = rgb green (of scale of 256) / 255

E'Y = 0.299 E'R + 0.587 E'G + 0.114 E'B
E'Cr = (E'R - E'Y)/1.402 = (0.701E'R - 0.587E'G - 0.114E'B)/1.402
E'Cb = (E'B - E'Y)/1.772 = (-.299E'R - 0.587E'G + .886E'B)/1.772

Y = Min( Max( 0, Round( 255 * E' Y ) ), 255 )
CB = Min( Max( 0, Round( 255 * E' CB + 128 ) ), 255 )
CR = Min( Max( 0, Round( 255 * E' CR + 128 ) ), 255 )

Do notice how these equation first normalize then expand, the normalization is thus not necessary.


if the byte ff appears through huffman coding follow it by 00 in the
image stream, the 00 will be ignored and the ff will be counted as image
data

also just in case you forget the huffman table used are labeled in the start of scan component,
I dont know why the quantization tbales and the huffman tables used are stored in different locations...
guess it allows for multiple huffman tables for different image scans...
the huffman tables used is defined in a a way such that the 1st 4 bits
of the byte define the dc table to use and the last 4 bits of the byte define
the ac table to use

huffman tables are comprised of two types
ac and dc
dc refers to the first number in the mcu, the number with the greatest importance
and ac refers to all others, with them having the greatest likelyhood to be zero
this information is not in the lovely ccoderun website, but
the huffman table type and table number is stored in the byte after the length
in the huffman table
this byte is called the huffman table in the ccoderun website.
it has the same storage method as the sos component, where the first 4 bits
of the byte refer ti which type it is, and the second 4 bits refer to the table index
it is. this means there can be a total of 8 huffman tables.
you can see this byte in the files, where after the huffman table lenght
the huffman tables have the bytes (looking at the byte after the length for four huffman tables)
00, 10, 01, 11
these bytes mean that the first huffman table was a dc table of index 0,
the second table was a ac table of index 0, the third a dc table of index 1,
and the fourth a ac table of index 1

this playlist goes over the huffman table stuff really well:
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
timestamp:9:33

the formal definition of the forward discrete cosine transform (FDCT)(the discrete cosine transfor that converst to compressed data):
Svu = 1/4*Cu*Cv*(x=0)∑(7)(Sys*cos(((2x+1)uπ)/16)cos(((2y+1)vπ)/16))
where:
Cu = 1/sqrt(2)
when u = 0
Cv = 1/sqrt(2)
when v = 0
Cu = 1
otherwise
Cv = 1
otherwise
u = new array y position (discrete-cosine array)
v = new array x position (discrete-cosine array)
Syx obviously refers to the non-discrete-cosine arrays position, x being column position and y being row position
Svu refers to the new arrays position, so u will be the column positon and v the row positon
notice how the cos values are actually static..., now I understand the bit shifting done
in the libjpeg
HOWEVER Notice that the Svu is not Syx, so this means that the new array iterates for every position
over the entire array, such that for the dc coeffient s(0)(0) it iterates over the entire array to find the dc coeffiecient
so the total number of iterations for a mcu of this is 64 * 64, as the array iterates over the entire array for each position
and the standard is 8x8
pg. 27
https://www.w3.org/Graphics/JPEG/itu-t81.pdf
or
ITU-T T.81 | ISO/IEC 10918-1


okay this is all the standard implementation of the dct algorthim, but as you noticed in libjpg, they do not use this algorithim
instead they use an algorithim that is equivalent and faster, the AAN algorithim
here are a collection of links that explian the algorithim and use it:
https://unix4lyfe.org/dct-1d/
https://codereview.stackexchange.com/questions/265527/faster-aan-algorithm-for-calculating-discrete-cosine-transform
https://unix4lyfe.org/dct/
http://board.flatassembler.net/topic.php?p=204231
https://thanglong.ece.jhu.edu/Tran/Pub/binDCT-VLSI.pdf
https://github.com/prtsh/aan_dct
https://github.com/phreda4/r4/blob/master/r4/Lib/loadjpg.txt
https://drdobbs.com/parallel/algorithm-alley/184410889
also the AANExample.c file has a version of it implemented

weird diagram can be found at:
http://board.flatassembler.net/topic.php?p=204231

weird diagram notes:
white dots: no operation
black dots: addition operation of connecting nodes
arrows: makes line that the arrows is on negative
boxes: multiplication of constant

okay to understand how the bitshifting works on rounding and unrounding the constants,
you do need to recognize that the flowcharts output side is not aligned with the input side...
f(4) is not on the same line of F(4).
but the aanexample algo has a technique that prevents the use of floating point numbers by
bit shifting by the power of 10, which is multiplying by a 1024, 2^10.
they then rectify this by bit-subtracting by 10, or whatever number is needed due to rounding at the end
very clever
also these guys store the dct as a double, which, I don't know about that
also notice the right side of the dct are multipliers of the values, not the end values themselves

Okay so IM TRYING TO FIND HOW THE FUCKING CB AND CR VALUES ARE STORED IN THE MCUS AND I CANT
FIGURE OUT HOW They ARE stored?? ARE THEY STORED RIGHT AFTER THE MCUS Y VALUES OR ARE THEY
COLLECTIVELY STORED AFTER 4 Y VALUE MCUS COMPONENTS? Downsampling is handled before the DCT so...
also the book has this information around pg 118

okay this might seem obvious but as shown above it kinda confused me? How does JPG determine which
color component it is on during the scan of the Image data? How does it know how long the segments
for the Y Cb and Cr components are? Well this is obvious it is done by the already defined sampling factor.
In the Start of Frame segment the component sampling section is also used to define the order of the components.
This defines which component comes first, but it also defines the lenght of the segments in the Image Data,
as the sampling factor determines how long each segment will be, either 64 or 16 signs long.
Based of this I still need to find out how to do a DCT on the 4x4 segments

okay I found the standard FDCT-II which is used for 4x4 dct, saved to SPIE09_odd_sized_transforms.pdf
its on pg 4, and its pretty simple as you can see
