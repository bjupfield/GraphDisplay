good but brief overview
https://github.com/corkami/formats/blob/master/image/jpeg.md

video discussing arithmetic coding for jpg, timestamp 10:20, for real explanation
https://www.youtube.com/watch?v=35f43OSIKXk

actual good intro:
https://www.ccoderun.ca/programming/2017-01-31_jpeg/

quantizition table:
https://www.quora.com/What-are-the-design-steps-for-jpeg-quantization-table
http://forum.doom9.org/showthread.php?t=54147&highlight=matrix
https://num.math.uni-goettingen.de/plonka/pdfs/bommer02.pdf
https://www.geeksforgeeks.org/discrete-cosine-transform-algorithm-program/#

jpeg symbols:
https://help.accusoft.com/ImageGear/v19.8/Windows/DLL/IGDLL-10-05.html
https://www.w3.org/Graphics/JPEG/itu-t81.pdf

okay I get it there is no DCT Tables, the alogirithim is just the same across all jpegs,
they all use DCT-II, which then is quantizised by the quanitization tables and is than
huffmaned with huffman tables

ITU defined formulas for RGB to YCbCr Conversion:

E'B = normalized blue = rgb blue (of scale of 256) / 255
E'R = normalized red = rgb red (of scale of 256) / 255
E'G = normalized green = rgb green (of scale of 256) / 255

E'Y = 0.299 E'R + 0.587 E'G + 0.114 E'B
E'Cr = (E'R - E'Y)/1.402 = (0.701E'R - 0.587E'G - 0.114E'B)/1.402
E'Cb = (E'B - E'Y)/1.772 = (-.299E'R - 0.587E'G + .886E'B)/1.772

Y = Min( Max( 0, Round( 255 * E' Y ) ), 255 )
CB = Min( Max( 0, Round( 255 * E' CB + 128 ) ), 255 )
CR = Min( Max( 0, Round( 255 * E' CR + 128 ) ), 255 )

Do notice how these equation first normalize then expand, the normalization is thus not necessary.
