good but brief overview
https://github.com/corkami/formats/blob/master/image/jpeg.md

video discussing arithmetic coding for jpg, timestamp 10:20, for real explanation
https://www.youtube.com/watch?v=35f43OSIKXk

actual good intro:
https://www.ccoderun.ca/programming/2017-01-31_jpeg/

quantizition table:
https://www.quora.com/What-are-the-design-steps-for-jpeg-quantization-table
http://forum.doom9.org/showthread.php?t=54147&highlight=matrix
https://num.math.uni-goettingen.de/plonka/pdfs/bommer02.pdf
https://www.geeksforgeeks.org/discrete-cosine-transform-algorithm-program/#

jpeg symbols:
https://help.accusoft.com/ImageGear/v19.8/Windows/DLL/IGDLL-10-05.html
https://www.w3.org/Graphics/JPEG/itu-t81.pdf

okay I get it there is no DCT Tables, the alogirithim is just the same across all jpegs,
they all use DCT-II, which then is quantizised by the quanitization tables and is than
huffmaned with huffman tables

ITU defined formulas for RGB to YCbCr Conversion:

E'B = normalized blue = rgb blue (of scale of 256) / 255
E'R = normalized red = rgb red (of scale of 256) / 255
E'G = normalized green = rgb green (of scale of 256) / 255

E'Y = 0.299 E'R + 0.587 E'G + 0.114 E'B
E'Cr = (E'R - E'Y)/1.402 = (0.701E'R - 0.587E'G - 0.114E'B)/1.402
E'Cb = (E'B - E'Y)/1.772 = (-.299E'R - 0.587E'G + .886E'B)/1.772

Y = Min( Max( 0, Round( 255 * E' Y ) ), 255 )
CB = Min( Max( 0, Round( 255 * E' CB + 128 ) ), 255 )
CR = Min( Max( 0, Round( 255 * E' CR + 128 ) ), 255 )

Do notice how these equation first normalize then expand, the normalization is thus not necessary.


if the byte ff appears through huffman coding follow it by 00 in the
image stream, the 00 will be ignored and the ff will be counted as image
data

also just in case you forget the huffman table used are labeled in the start of scan component,
I dont know why the quantization tbales and the huffman tables used are stored in different locations...
guess it allows for multiple huffman tables for different image scans...
the huffman tables used is defined in a a way such that the 1st 4 bits
of the byte define the dc table to use and the last 4 bits of the byte define
the ac table to use

huffman tables are comprised of two types
ac and dc
dc refers to the first number in the mcu, the number with the greatest importance
and ac refers to all others, with them having the greatest likelyhood to be zero
this information is not in the lovely ccoderun website, but
the huffman table type and table number is stored in the byte after the length
in the huffman table
this byte is called the huffman table in the ccoderun website.
it has the same storage method as the sos component, where the first 4 bits
of the byte refer ti which type it is, and the second 4 bits refer to the table index
it is. this means there can be a total of 8 huffman tables.
you can see this byte in the files, where after the huffman table lenght
the huffman tables have the bytes (looking at the byte after the length for four huffman tables)
00, 10, 01, 11
these bytes mean that the first huffman table was a dc table of index 0,
the second table was a ac table of index 0, the third a dc table of index 1,
and the fourth a ac table of index 1

this playlist goes over the huffman table stuff really well:
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
timestamp:9:33

the formal definition of the forward discrete cosine transform (FDCT)(the discrete cosine transfor that converst to compressed data):
Svu = 1/4*Cu*Cv*(x=0)∑(7)(Sys*cos(((2x+1)uπ)/16)cos(((2y+1)vπ)/16))
where:
Cu = 1/sqrt(2)
when u = 0
Cv = 1/sqrt(2)
when v = 0
Cu = 1
otherwise
Cv = 1
otherwise
u = new array y position (discrete-cosine array)
v = new array x position (discrete-cosine array)
Syx obviously refers to the non-discrete-cosine arrays position, x being column position and y being row position
Svu refers to the new arrays position, so u will be the column positon and v the row positon
notice how the cos values are actually static..., now I understand the bit shifting done
in the libjpeg
HOWEVER Notice that the Svu is not Syx, so this means that the new array iterates for every position
over the entire array, such that for the dc coeffient s(0)(0) it iterates over the entire array to find the dc coeffiecient
so the total number of iterations for a mcu of this is 64 * 64, as the array iterates over the entire array for each position
and the standard is 8x8
pg. 27
https://www.w3.org/Graphics/JPEG/itu-t81.pdf
or
ITU-T T.81 | ISO/IEC 10918-1


okay this is all the standard implementation of the dct algorthim, but as you noticed in libjpg, they do not use this algorithim
instead they use an algorithim that is equivalent and faster, the AAN algorithim
here are a collection of links that explian the algorithim and use it:
https://unix4lyfe.org/dct-1d/
https://codereview.stackexchange.com/questions/265527/faster-aan-algorithm-for-calculating-discrete-cosine-transform
https://unix4lyfe.org/dct/
http://board.flatassembler.net/topic.php?p=204231
https://thanglong.ece.jhu.edu/Tran/Pub/binDCT-VLSI.pdf
https://github.com/prtsh/aan_dct
https://github.com/phreda4/r4/blob/master/r4/Lib/loadjpg.txt
also the AANExample.c file has a version of it implemented