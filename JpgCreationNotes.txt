good but brief overview
https://github.com/corkami/formats/blob/master/image/jpeg.md

video discussing arithmetic coding for jpg, timestamp 10:20, for real explanation
https://www.youtube.com/watch?v=35f43OSIKXk

actual good intro:
https://www.ccoderun.ca/programming/2017-01-31_jpeg/

quantizition table:
https://www.quora.com/What-are-the-design-steps-for-jpeg-quantization-table
http://forum.doom9.org/showthread.php?t=54147&highlight=matrix
https://num.math.uni-goettingen.de/plonka/pdfs/bommer02.pdf
https://www.geeksforgeeks.org/discrete-cosine-transform-algorithm-program/#

jpeg symbols:
https://help.accusoft.com/ImageGear/v19.8/Windows/DLL/IGDLL-10-05.html
https://www.w3.org/Graphics/JPEG/itu-t81.pdf

okay I get it there is no DCT Tables, the alogirithim is just the same across all jpegs,
they all use DCT-II, which then is quantizised by the quanitization tables and is than
huffmaned with huffman tables

ITU defined formulas for RGB to YCbCr Conversion:

E'B = normalized blue = rgb blue (of scale of 256) / 255
E'R = normalized red = rgb red (of scale of 256) / 255
E'G = normalized green = rgb green (of scale of 256) / 255

E'Y = 0.299 E'R + 0.587 E'G + 0.114 E'B
E'Cr = (E'R - E'Y)/1.402 = (0.701E'R - 0.587E'G - 0.114E'B)/1.402
E'Cb = (E'B - E'Y)/1.772 = (-.299E'R - 0.587E'G + .886E'B)/1.772

Y = Min( Max( 0, Round( 255 * E' Y ) ), 255 )
CB = Min( Max( 0, Round( 255 * E' CB + 128 ) ), 255 )
CR = Min( Max( 0, Round( 255 * E' CR + 128 ) ), 255 )

Do notice how these equation first normalize then expand, the normalization is thus not necessary.


if the byte ff appears through huffman coding follow it by 00 in the
image stream, the 00 will be ignored and the ff will be counted as image
data

also just in case you forget the huffman table used are labeled in the start of scan component,
I dont know why the quantization tbales and the huffman tables used are stored in different locations...
guess it allows for multiple huffman tables for different image scans...
the huffman tables used is defined in a a way such that the 1st 4 bits
of the byte define the dc table to use and the last 4 bits of the byte define
the ac table to use

huffman tables are comprised of two types
ac and dc
dc refers to the first number in the mcu, the number with the greatest importance
and ac refers to all others, with them having the greatest likelyhood to be zero
this information is not in the lovely ccoderun website, but
the huffman table type and table number is stored in the byte after the length
in the huffman table
this byte is called the huffman table in the ccoderun website.
it has the same storage method as the sos component, where the first 4 bits
of the byte refer ti which type it is, and the second 4 bits refer to the table index
it is. this means there can be a total of 8 huffman tables.
you can see this byte in the files, where after the huffman table lenght
the huffman tables have the bytes (looking at the byte after the length for four huffman tables)
00, 10, 01, 11
these bytes mean that the first huffman table was a dc table of index 0,
the second table was a ac table of index 0, the third a dc table of index 1,
and the fourth a ac table of index 1

this playlist goes over the huffman table stuff really well:
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
timestamp:9:33

the formal definition of the forward discrete cosine transform (FDCT)(the discrete cosine transfor that converst to compressed data):
Svu = 1/4*Cu*Cv*(x=0)∑(7)(Sys*cos(((2x+1)uπ)/16)cos(((2y+1)vπ)/16))
where:
Cu = 1/sqrt(2)
when u = 0
Cv = 1/sqrt(2)
when v = 0
Cu = 1
otherwise
Cv = 1
otherwise
u = new array y position (discrete-cosine array)
v = new array x position (discrete-cosine array)
Syx obviously refers to the non-discrete-cosine arrays position, x being column position and y being row position
Svu refers to the new arrays position, so u will be the column positon and v the row positon
notice how the cos values are actually static..., now I understand the bit shifting done
in the libjpeg
HOWEVER Notice that the Svu is not Syx, so this means that the new array iterates for every position
over the entire array, such that for the dc coeffient s(0)(0) it iterates over the entire array to find the dc coeffiecient
so the total number of iterations for a mcu of this is 64 * 64, as the array iterates over the entire array for each position
and the standard is 8x8
pg. 27
https://www.w3.org/Graphics/JPEG/itu-t81.pdf
or
ITU-T T.81 | ISO/IEC 10918-1


okay this is all the standard implementation of the dct algorthim, but as you noticed in libjpg, they do not use this algorithim
instead they use an algorithim that is equivalent and faster, the AAN algorithim
here are a collection of links that explian the algorithim and use it:
https://unix4lyfe.org/dct-1d/
https://codereview.stackexchange.com/questions/265527/faster-aan-algorithm-for-calculating-discrete-cosine-transform
https://unix4lyfe.org/dct/
http://board.flatassembler.net/topic.php?p=204231
https://thanglong.ece.jhu.edu/Tran/Pub/binDCT-VLSI.pdf
https://github.com/prtsh/aan_dct
https://github.com/phreda4/r4/blob/master/r4/Lib/loadjpg.txt
https://drdobbs.com/parallel/algorithm-alley/184410889
also the AANExample.c file has a version of it implemented

weird diagram can be found at:
http://board.flatassembler.net/topic.php?p=204231

weird diagram notes:
white dots: no operation
black dots: addition operation of connecting nodes
arrows: makes line that the arrows is on negative
boxes: multiplication of constant

okay to understand how the bitshifting works on rounding and unrounding the constants,
you do need to recognize that the flowcharts output side is not aligned with the input side...
f(4) is not on the same line of F(4).
but the aanexample algo has a technique that prevents the use of floating point numbers by
bit shifting by the power of 10, which is multiplying by a 1024, 2^10.
they then rectify this by bit-subtracting by 10, or whatever number is needed due to rounding at the end
very clever
also these guys store the dct as a double, which, I don't know about that
also notice the right side of the dct are multipliers of the values, not the end values themselves

Okay so IM TRYING TO FIND HOW THE FUCKING CB AND CR VALUES ARE STORED IN THE MCUS AND I CANT
FIGURE OUT HOW They ARE stored?? ARE THEY STORED RIGHT AFTER THE MCUS Y VALUES OR ARE THEY
COLLECTIVELY STORED AFTER 4 Y VALUE MCUS COMPONENTS? Downsampling is handled before the DCT so...
also the book has this information around pg 118

okay this might seem obvious but as shown above it kinda confused me? How does JPG determine which
color component it is on during the scan of the Image data? How does it know how long the segments
for the Y Cb and Cr components are? Well this is obvious it is done by the already defined sampling factor.
In the Start of Frame segment the component sampling section is also used to define the order of the components.
This defines which component comes first, but it also defines the lenght of the segments in the Image Data,
as the sampling factor determines how long each segment will be, either 64 or 16 signs long.
Based of this I still need to find out how to do a DCT on the 4x4 segments

okay I found the standard FDCT-II which is used for 4x4 dct, saved to SPIE09_odd_sized_transforms.pdf
its on pg 4, and its pretty simple as you can see


//okay below here is going to be my detailed notes on Jpg huffman tables and coding
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3
https://www.youtube.com/watch?v=TlrNCT15NM4&list=PLpsTn9TA_Q8VMDyOPrDKmSJYt1DLgDZU4&index=3


huffman codes cannot have value start with the value of another huffman code, obvious reasons,
The 16 byte info in the jpg huffman table defines the amount of huffman codes of each length there are
^ Part 1 21:24
The Huffman Codes are stored in an odd way. The Part 1 describes it a 25:00 but it stores it in the algorithim
of bit shifiting the the code to the left by 1 every bit size addition, and adding one for every new code
so the first code will be a code of 0 * the size of the code, the second if its on the same byte size will be
the second will be 0 * size of code with the last zero being changed to 1

okay part 2 finally has something useful
timestamp 21:00 shows howsymbols are related to the huffman code... suprise suprise the symbols
are stored in a single array taht corresponds to the which code is being used by in the huffman code
array. although the huffman code arrays is only 16 bytes long, because it stores more information the codes
will correspond to the table in this way
-> we apply this by now knowing how to convert the symbols to the code,
iterate through all the mcus find the frequency of all values, 
then we organize the frequencies from most frequent to least frequent
then we count how many values there are
then based on the number of values we create our huffman table
by the method in the part 1 section above, we organize the values into the least possible length
huffman table, which is to group the least frequency values with the least, add the frequencies of the least together,
and regressively group them
ex:
Fr|valu
10|2
6|3
2|1
2|5
1|7
1|8

we would group the values 8 and 7 together, the new frequency of this pair would be 2,
than we would group the next tow lowest frequencies together. However now we have three with the 
value of 2 so what do we do? we group the pair with an arbitraly choosen value. So we would group
the pair of 8 and 7 with the value 5. Now we have a group comrpised of pair 8 and 7, and 5 with a frequency value of 4.
We than group the lowest frequency values together. Which are the 1 and the above group. Now we have a new group of frequency 6,
we than group this group with value 3, and then we have a group of frequency 12, which we group with value 2, which concludes the table.
The groups i think are something like the coefficient outputs are the position in this group that the grouping algo has created.

okay I think we can calculate the coefficient values with how bit shifting from the left the coefficient for the value
whenver its grouped.
so like the value 7 in the example above would start out as 1 or 0, just arbitrarily, but than when its grouped with
8 it would be bit shifted from the left by 1 resulting in 01 or 00, then when that group is grouped with the value 5 it would
be bit shifted again by 1 resulting in that group of the values 8 and 7, and 5 coefficients being 001 and 000, and 01
wait that doesnt work... hmmmm
okay to solve this we need to look at how the huffman coefficients are generated for jpg
part 1 timestamp 25:00 covers this


okay I also stopped watching the thing at 21:33